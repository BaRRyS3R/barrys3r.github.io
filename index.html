<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AirDraw Fullscreen</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
    }
    #stage {
      position: relative;
      width: 100%;
      height: 100%;
    }
    #video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    #hint {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 6px 12px;
      border-radius: 12px;
      font-size: 14px;
      font-family: sans-serif;
    }
  </style>
</head>
<body>
  <div id="stage">
    <video id="video" autoplay playsinline></video>
    <canvas id="draw"></canvas>
    <canvas id="overlay"></canvas>
    <div id="hint">Разрешите доступ к камере</div>
  </div>

  <script type="module">
    import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7";

    const ui = {
      video: document.getElementById('video'),
      draw: document.getElementById('draw'),
      overlay: document.getElementById('overlay'),
      hint: document.getElementById('hint'),
    };

    const state = {
      landmarker: null,
      lastIdxPt: null,
      pinchActive: false,
    };

    function resizeCanvases() {
      for (const c of [ui.draw, ui.overlay]) {
        c.width = window.innerWidth * devicePixelRatio;
        c.height = window.innerHeight * devicePixelRatio;
        c.style.width = window.innerWidth + 'px';
        c.style.height = window.innerHeight + 'px';
      }
    }
    window.addEventListener('resize', resizeCanvases);

    async function setupCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user' }, audio: false
      });
      ui.video.srcObject = stream;
      await ui.video.play();
    }

    async function setupLandmarker() {
      const resolver = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7/wasm"
      );
      state.landmarker = await HandLandmarker.createFromOptions(resolver, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
        },
        runningMode: "VIDEO",
        numHands: 1,
      });
    }

    function normToPx(pt, w, h) {
      return { x: pt.x * w, y: pt.y * h };
    }
    function distance(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }
    function drawLandmarks(ctx, landmarks, w, h) {
      ctx.clearRect(0, 0, w, h);
      ctx.strokeStyle = "rgba(0,255,0,0.6)";
      ctx.fillStyle = "rgba(0,255,0,0.9)";
      ctx.lineWidth = 2 * devicePixelRatio;

      // Connections
      const conns = [
        [0,1],[1,2],[2,3],[3,4],
        [0,5],[5,6],[6,7],[7,8],
        [5,9],[9,10],[10,11],[11,12],
        [9,13],[13,14],[14,15],[15,16],
        [13,17],[0,17],[17,18],[18,19],[19,20]
      ];
      ctx.beginPath();
      for (const [a,b] of conns) {
        const A = normToPx(landmarks[a], w, h);
        const B = normToPx(landmarks[b], w, h);
        ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y);
      }
      ctx.stroke();

      for (const p of landmarks) {
        const P = normToPx(p, w, h);
        ctx.beginPath();
        ctx.arc(P.x, P.y, 4 * devicePixelRatio, 0, Math.PI*2);
        ctx.fill();
      }
    }
    function drawLine(ctx, from, to) {
      ctx.strokeStyle = "#ff0";
      ctx.lineWidth = 6 * devicePixelRatio;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.stroke();
    }

    async function start() {
      ui.hint.textContent = "Запрашиваем камеру…";
      await setupCamera();
      resizeCanvases();
      ui.hint.textContent = "Загружаем модель…";
      await setupLandmarker();
      ui.hint.textContent = "Покажите руку и соедините большой + указательный палец";

      loop();
    }

    function loop() {
      const { videoWidth: vw, videoHeight: vh } = ui.video;
      if (vw === 0 || vh === 0) { requestAnimationFrame(loop); return; }

      const W = ui.draw.width, H = ui.draw.height;
      const ctxOverlay = ui.overlay.getContext('2d');
      const ctxDraw = ui.draw.getContext('2d');

      const now = performance.now();
      const result = state.landmarker.detectForVideo(ui.video, now);

      if (result?.landmarks?.[0]) {
        const lm = result.landmarks[0];
        drawLandmarks(ctxOverlay, lm, W, H);

        const thumbTip = lm[4];
        const indexTip = lm[8];
        const pinch = distance(thumbTip, indexTip) < 0.04; // нормализованный порог

        const idxPx = normToPx(indexTip, W, H);

        if (pinch) {
          if (state.lastIdxPt) drawLine(ctxDraw, state.lastIdxPt, idxPx);
          state.lastIdxPt = idxPx;
          ui.hint.textContent = "Рисуем… разожмите пальцы чтобы остановить";
        } else {
          state.lastIdxPt = null;
          ui.hint.textContent = "Покажите pinch-жест чтобы рисовать";
        }
      } else {
        ctxOverlay.clearRect(0, 0, W, H);
        state.lastIdxPt = null;
        ui.hint.textContent = "Рука не найдена";
      }

      requestAnimationFrame(loop);
    }

    if (!navigator.mediaDevices?.getUserMedia) {
      ui.hint.textContent = "Этот браузер не поддерживает getUserMedia()";
    } else {
      start().catch(err => {
        console.error(err);
        ui.hint.textContent = "Ошибка инициализации камеры";
      });
    }
  </script>
</body>
</html>