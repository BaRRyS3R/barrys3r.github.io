<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AirDraw — draw with your fingers</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; background: #0b0f19; }
    .glass { background: rgba(255,255,255,0.06); backdrop-filter: blur(8px); }
    .hint { text-shadow: 0 1px 12px rgba(0,0,0,0.5);} 
    canvas { touch-action: none; }
  </style>
</head>
<body class="text-slate-100">
  <div class="min-h-screen flex flex-col">
    <!-- Header -->
    <header class="p-4 md:p-6 flex items-center justify-between">
      <h1 class="text-xl md:text-2xl font-semibold tracking-tight">AirDraw <span class="text-slate-400">· pinch to paint</span></h1>
      <div class="text-xs md:text-sm text-slate-400">Webcam + Hand Tracking (MediaPipe)</div>
    </header>

    <!-- Main -->
    <main class="flex-1 px-4 md:px-6 pb-6 grid lg:grid-cols-[1fr,380px] gap-4 md:gap-6">
      <!-- Stage -->
      <section class="relative rounded-2xl glass border border-white/10 overflow-hidden aspect-video lg:aspect-auto flex items-center justify-center">
        <!-- Live video (hidden) -->
        <video id="video" autoplay playsinline class="hidden"></video>

        <!-- Drawing + overlay canvases -->
        <canvas id="draw" class="absolute inset-0"></canvas>
        <canvas id="overlay" class="absolute inset-0 pointer-events-none"></canvas>

        <!-- Center hint -->
        <div id="hint" class="hint absolute inset-x-0 bottom-4 mx-auto w-fit px-3 py-1.5 rounded-full text-xs md:text-sm text-slate-200 bg-black/40 border border-white/10">Allow camera access to start</div>

        <!-- Error banner -->
        <div id="error" class="hidden absolute top-4 left-4 right-4 md:left-6 md:right-6 p-3 rounded-xl bg-red-500/10 border border-red-500/30 text-red-200 text-sm"></div>
      </section>

      <!-- Controls -->
      <aside class="rounded-2xl glass border border-white/10 p-4 md:p-5 space-y-5">
        <div class="flex items-center justify-between">
          <div class="font-medium">Controls</div>
          <button id="btnClear" class="px-3 py-1.5 rounded-xl bg-white/10 hover:bg-white/20 border border-white/10 text-sm">Clear</button>
        </div>

        <div class="grid grid-cols-2 gap-3">
          <label class="col-span-2 flex items-center justify-between gap-3">
            <span class="text-sm text-slate-300">Draw on pinch</span>
            <input id="toggleDraw" type="checkbox" class="w-4 h-4 accent-white" checked>
          </label>
          <label class="col-span-2 flex items-center justify-between gap-3">
            <span class="text-sm text-slate-300">Show landmarks</span>
            <input id="toggleDots" type="checkbox" class="w-4 h-4 accent-white" checked>
          </label>
          <label class="col-span-2 flex items-center justify-between gap-3">
            <span class="text-sm text-slate-300">Mirror camera</span>
            <input id="toggleMirror" type="checkbox" class="w-4 h-4 accent-white" checked>
          </label>
          <label class="flex items-center justify-between gap-3">
            <span class="text-sm text-slate-300">Brush size</span>
            <input id="size" type="range" min="2" max="20" value="6" class="w-full">
          </label>
          <label class="flex items-center justify-between gap-3">
            <span class="text-sm text-slate-300">Pinch threshold</span>
            <input id="threshold" type="range" min="2" max="10" value="4" class="w-full">
          </label>
          <label class="flex items-center justify-between gap-3 col-span-2">
            <span class="text-sm text-slate-300">Brush color</span>
            <input id="color" type="color" value="#ffffff" class="w-10 h-8 p-0 bg-transparent border border-white/20 rounded">
          </label>
        </div>

        <div class="pt-1 text-xs text-slate-400 leading-relaxed">
          Pinch = thumb tip + index tip close together. Move your hand to draw. Release to stop.
        </div>

        <div class="pt-2 flex gap-3">
          <button id="btnSave" class="px-3 py-1.5 rounded-xl bg-white/10 hover:bg-white/20 border border-white/10 text-sm">Save PNG</button>
          <button id="btnResetCam" class="px-3 py-1.5 rounded-xl bg-white/10 hover:bg-white/20 border border-white/10 text-sm">Restart Camera</button>
        </div>
      </aside>
    </main>

    <footer class="p-4 md:p-6 text-xs text-slate-500">Built with MediaPipe Tasks • Runs fully in your browser</footer>
  </div>

  <script type="module">
    import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7";

    const ui = {
      video: document.getElementById('video'),
      draw: document.getElementById('draw'),
      overlay: document.getElementById('overlay'),
      hint: document.getElementById('hint'),
      error: document.getElementById('error'),
      btnClear: document.getElementById('btnClear'),
      btnSave: document.getElementById('btnSave'),
      btnResetCam: document.getElementById('btnResetCam'),
      toggleDraw: document.getElementById('toggleDraw'),
      toggleDots: document.getElementById('toggleDots'),
      toggleMirror: document.getElementById('toggleMirror'),
      size: document.getElementById('size'),
      color: document.getElementById('color'),
      threshold: document.getElementById('threshold'),
    };

    const state = {
      running: false,
      landmarker: null,
      lastIdxPt: null, // last index finger point in px
      pinchActive: false,
      mirror: true,
    };

    function setError(msg) {
      ui.error.textContent = msg;
      ui.error.classList.remove('hidden');
    }

    function clearError() {
      ui.error.classList.add('hidden');
      ui.error.textContent = '';
    }

    function resizeCanvases() {
      const rect = ui.draw.getBoundingClientRect();
      for (const c of [ui.draw, ui.overlay]) {
        c.width = Math.floor(rect.width * devicePixelRatio);
        c.height = Math.floor(rect.height * devicePixelRatio);
        c.style.width = rect.width + 'px';
        c.style.height = rect.height + 'px';
      }
    }

    window.addEventListener('resize', resizeCanvases);

    async function setupCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
        ui.video.srcObject = stream;
        await ui.video.play();
        ui.hint.textContent = 'Initializing model…';
      } catch (e) {
        setError('Camera access denied or unavailable. Please allow camera permissions and reload.');
        throw e;
      }
    }

    async function setupLandmarker() {
      const filesetResolver = await FilesetResolver.forVisionTasks(
        // Path where the wasm files are hosted
        'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7/wasm'
      );
      state.landmarker = await HandLandmarker.createFromOptions(filesetResolver, {
        baseOptions: {
          modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
        },
        runningMode: 'VIDEO',
        numHands: 1,
      });
    }

    function normToPx(pt, w, h, mirror) {
      const x = (mirror ? (1 - pt.x) : pt.x) * w;
      const y = pt.y * h;
      return { x, y };
    }

    function drawLandmarks(ctx, landmarks, w, h, mirror) {
      if (!landmarks) return;
      ctx.save();
      ctx.clearRect(0, 0, w, h);
      ctx.lineWidth = 2 * devicePixelRatio;
      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.fillStyle = 'rgba(255,255,255,0.9)';

      // Optional: simple skeleton
      const connections = [
        [0,1],[1,2],[2,3],[3,4],
        [0,5],[5,6],[6,7],[7,8],
        [5,9],[9,10],[10,11],[11,12],
        [9,13],[13,14],[14,15],[15,16],
        [13,17],[0,17],[17,18],[18,19],[19,20]
      ];

      ctx.beginPath();
      for (const [a,b] of connections) {
        const A = normToPx(landmarks[a], w, h, mirror);
        const B = normToPx(landmarks[b], w, h, mirror);
        ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y);
      }
      ctx.stroke();

      for (const p of landmarks) {
        const P = normToPx(p, w, h, mirror);
        ctx.beginPath(); ctx.arc(P.x, P.y, 3 * devicePixelRatio, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }

    function distance(a, b) {
      const dx = a.x - b.x, dy = a.y - b.y; return Math.hypot(dx, dy);
    }

    function drawLine(ctx, from, to) {
      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = ui.color.value;
      ctx.lineWidth = Number(ui.size.value) * devicePixelRatio;
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.stroke();
      ctx.restore();
    }

    function clearCanvas() {
      ui.draw.getContext('2d').clearRect(0, 0, ui.draw.width, ui.draw.height);
    }

    ui.btnClear.addEventListener('click', clearCanvas);
    ui.btnSave.addEventListener('click', () => {
      const a = document.createElement('a');
      a.download = 'airdraw.png';
      a.href = ui.draw.toDataURL('image/png');
      a.click();
    });
    ui.btnResetCam.addEventListener('click', async () => {
      await start();
    });

    ui.toggleMirror.addEventListener('change', () => { state.mirror = ui.toggleMirror.checked; });

    async function start() {
      try {
        clearError();
        state.lastIdxPt = null;
        state.pinchActive = false;
        state.mirror = ui.toggleMirror.checked;
        ui.hint.textContent = 'Requesting camera…';
        await setupCamera();
        resizeCanvases();
        ui.hint.textContent = 'Loading hand tracker…';
        await setupLandmarker();
        ui.hint.textContent = 'Show your hand and pinch to draw';
        state.running = true;
        loop();
      } catch (e) {
        console.error(e);
        ui.hint.textContent = 'Error initializing';
      }
    }

    async function loop() {
      if (!state.running) return;
      const { videoWidth: vw, videoHeight: vh } = ui.video;
      if (vw === 0 || vh === 0) {
        requestAnimationFrame(loop); return;
      }

      const ctxOverlay = ui.overlay.getContext('2d');
      const ctxDraw = ui.draw.getContext('2d');
      const W = ui.draw.width, H = ui.draw.height;

      const now = performance.now();
      const result = state.landmarker.detectForVideo(ui.video, now);

      if (result && result.landmarks && result.landmarks[0]) {
        const lm = result.landmarks[0];
        const thumbTip = lm[4];
        const indexTip = lm[8];

        // Normalized (0..1) distance; threshold slider is 0.0X
        const pinchNorm = distance(thumbTip, indexTip);
        const threshold = Number(ui.threshold.value) / 100; // e.g. 0.04
        const pinch = ui.toggleDraw.checked && pinchNorm < threshold;

        if (ui.toggleDots.checked) {
          drawLandmarks(ctxOverlay, lm, W, H, state.mirror);
        } else {
          ctxOverlay.clearRect(0, 0, W, H);
        }

        const idxPx = normToPx(indexTip, W, H, state.mirror);

        if (pinch) {
          if (state.lastIdxPt) {
            drawLine(ctxDraw, state.lastIdxPt, idxPx);
          }
          state.lastIdxPt = idxPx;
          state.pinchActive = true;
          ui.hint.textContent = 'Drawing… release to stop';
        } else {
          state.lastIdxPt = null;
          if (state.pinchActive) ui.hint.textContent = 'Released';
          state.pinchActive = false;
        }
      } else {
        // No hand detected
        ui.overlay.getContext('2d').clearRect(0, 0, W, H);
        state.lastIdxPt = null;
        ui.hint.textContent = 'Show your hand to start';
      }

      requestAnimationFrame(loop);
    }

    // Kickoff
    if (!('mediaDevices' in navigator) || !('getUserMedia' in navigator.mediaDevices)) {
      setError('This browser does not support getUserMedia(). Try Chrome/Edge/Firefox or a recent mobile browser.');
      ui.hint.textContent = 'Unsupported browser';
    } else {
      start();
    }
  </script>
</body>
</html>
